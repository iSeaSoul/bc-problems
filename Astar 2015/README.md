### 大搬家 remove

递推。考虑置换群的性质，可以得到$f(n)=f(n-1)+(n-1)*f(n-2)$。

### 最强密码 ultra

DP。先解决最短长度。从后往前扫描，设位置为Pos_i，那么
$minLen(Pos_i)=min\{minLen(minPos(c))|'a'<=c<='z'\}+1$，minPos记录每个字母出现过的index最小的位置。复杂度为O(len*26)。

个数的DP类似。但要记录两个统计值，当前最短长度的个数，与当前最短长度+1的个数。

### 平衡大师 balance

为了简化问题，考虑差值为0的情况，将每个点拆成两个点，右边点到左边对应的点的流量无穷，费用为0，每条边的费用和流量都为1。保留最多的边，就是一个最小费用循环流，注意普通的费用流是不能处理负环的，使用消圈算法来解决这个问题。

对于差值不为0的情况，二分或枚举最大差值。用额外的一个magic点来平衡度数的差值，使所有不平衡的度数差都从这个magic点回流，而用到这个点的最大流量来限制最大差值。

### 追星族 starchaser

首先，答案要么是整数，要么是x/2。为了避免二分误差，将坐标值扩大两倍，在整数域上进行二分。

将坐标轴旋转45度，曼哈顿距离覆盖的区域可以从菱形转化为一个矩形。将所有点按时间排序，在二分验证最大距离时，顺序扫描一遍，根据间隔时间扩展当前矩形区域然后求矩形的并，验证每个时刻的矩形都至少包含一个点。

### 蜀道难 tough

DP的单调性优化。环形处理起来比较烦一点，先处理会经过0点这样环绕的路，然后限制单调队列的选取范围。

先考虑绕过0点这样的路，这些点对的id差一定超过n/2，两个指针分别扫描前一半后后一半，前一半在扫描过程中保存到0点的最大距离，后一半的指针计算出当前位置到0点的距离，和当前的最大距离相加。

再来看正常的不绕过0点的DP，$dp[i] = max\{dis(i, j) = h[i]+h[j]+(i-j)*R | j < i\}$，利用单调性优化，保存最大的$h[j]-j*R$即可优化成O(N)。

### 翻转游戏 flip

第一行的格子状态会决定后面格子的状态，每个格子如果要被翻转成白色，假设可以列出一个异或方程，形式为$nimsum(ai*xi)=b$，其中$1<=i<=N$。

那么有解的充要条件是每个格子的异或方程等于周围四个格子的异或方程的异或结果，也就是每个格子与其周围四个格子的异或方程的异或结果应该是0=0。这样可以递推到最后一行。

对于坏掉的格子，加入其上方格子的异或方程来确保它没有被翻转。

### 魔法因子 magic

假设数字为Num，长度为N，首位为A，末位为B，那么$Num+(B-A)(10^{N-1}-1)=Num*X$，所以$Num=\frac{(B-A)(10^{N-1}-1)}{X-1}$。枚举A、B、N，求出Num然后验证即可。

### 行路难 way

字符串为路径的最短路，使用带堆的dijkstra算法。如果当前队列里面的字符串长度已经超过N*最大长度，并且两个点可达，那么两点间一定存在负环。

iSea @ May. 14th, 2015