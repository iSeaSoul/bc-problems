###A - Revenge of LIS

要求求出第二长的LIS，如果所有上升子序列按长度降序排序。

DP可以以当前数字为求出当前结尾的LIS，LIS的更新一定是$DP[j_{lessthani}] + 1$，所以第二小的一定也是这个LIS数组里第二小的。排序输出第二小的即可。对于$N\le1000$，$O(N^2)$可以满足。当然你也可以花上**（几十秒）**把它优化成$O(NlogN)$的。

复杂度：$O(N^2)$

难度：$0.5/5$

###B - Revenge of Nim

Nim游戏变成从前往后有序的，谁是winner？

如果当前堆数目为1，玩家没有选择，只能取走。如此直到第一个不为1的堆，则当前回合行动者必胜。考虑之后的状态为S，如果S为必败态，则玩家可以取完当前堆，否则，将当前堆数目变为1。

复杂度：$O(N)$

难度：$1.0/5$

###C - Revenge of kNN

一维的kNN问题，询问某个点的是求出kNN值并替换之。

排序，对每个询问线性扫描。左右两个指针依次比较距离与index即可。注意询问的ID要对应到排序后的ID，并且排序规则要严格按照题目要求的。

复杂度： $O(NlogN + MK)$

难度：$1.5/5$

###D - Revenge of LIS II

求出LIS长度为K的N排列个数。

回顾一下LIS的$O(NlogN)$做法：保留一个单调递增的数列，分别表示长度为i的递增子序列结尾的最小值。对于新的数字，要么最大长度加1，要么替换掉第一个大于它的数字。

这样我们得到一个$O(3^N  * N^3)$的DP。0表示数字未用，1表示数字用过但不在这个数列里面，2表示数字用过并且在数字里面，每次转移枚举未用的数字，按照上述规则更新这个数列值。

但是对于$N=15$，需要的空间和时间复杂度依旧太大，于是，打表提交。

复杂度： $O(3^N * N^3)$ -> 打表 $O(1)$

那个... 实在是不好意思，上面是未更新前的题解。事实上验题的elfness大大提出了一个更优美的$O(2^N * N^2)$的做法。

按数字1-N的顺序依次枚举添加的数字，用$2^N$的状态保存在那个min数组中的数字，每次新添加数字可以根据位置计算出新的min数组。

怎么快速计算呢？这里如果枚举N的位置是不可行的，这样$2^n$的state记录的信息不够。很巧妙的思路是枚举放在当前位置的数字，比如说1-N-1的排列状态下，枚举第N位为K，那么1-N-1位的$>=k$的数字全加1，就得到了一个1-N的排列。

所以就*厚颜无耻*的把N加到18了，哈哈。

复杂度： $O(2^N * N^2)$

难度：$3.0/5$

- - -

P.S. 本来的题目是BCD + 一个更难的题目，降低了一个梯度的难度并且加强了pretest来为了鼓励新手，希望大家玩的开心，大神们也不要鄙视题目太水。

PP.S. 可能最近还继续这个系列，一起来体验各种被模板的可怜算法之Revenge吧。